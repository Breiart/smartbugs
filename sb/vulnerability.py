import re
import sb.logging
import sb.tools

class VulnerabilityAnalyzer:
    """Analyze findings and classify vulnerabilities."""

    SWC_MAP = {
        "SWC-101": "INTEGER_OVERFLOW",
        "SWC-104": "LOW_LEVEL_CALL",
        "SWC-106": "SUICIDAL",
        "SWC-107": "REENTRANCY",
        "SWC-109": "UNINITIALIZED_STORAGE_POINTER",
        "SWC-110": "ASSERT_VIOLATION",
        "SWC-112": "DELEGATECALL",
        "SWC-113": "TX_ORIGIN",
        "SWC-114": "TOD",
        "SWC-115": "BLOCK_DEPENDENCE",
        "SWC-123": "WRITE_TO_ARBITRARY_STORAGE",
        "SWC-135": "GREEDY_CONTRACT",
        "SWC-136": "UNINITIALIZED_STORAGE",
        "SWC-138": "DOS_GAS_LIMIT",
    }

    KEYWORDS = {
        "INTEGER_OVERFLOW": ["overflow", "underflow", "arithmetic error", "unchecked math"],
        "LOW_LEVEL_CALL": ["call.value", "low level call", "unchecked call", "external call without check", "SOLIDITY_CALL_WITHOUT_DATA"],
        "SUICIDAL": ["suicidal", "selfdestruct", "self-destruct", "destructible"],
        "REENTRANCY": ["reentrancy", "re-entrancy", "reentry"],
        "UNINITIALIZED_STORAGE_POINTER": ["uninitialized storage", "default value", "null storage"],
        "ASSERT_VIOLATION": ["assertion failed", "assert failed", "assert violation"],
        
        "DELEGATECALL": ["delegatecall", "delegate call"],
        "TX_ORIGIN": ["tx.origin", "tx origin", "origin authentication"],
        "TOD": ["transaction order dependence", "tod"],
        "BLOCK_DEPENDENCE": ["block.timestamp", "now", "blockhash"],
        "WRITE_TO_ARBITRARY_STORAGE": ["arbitrary storage write", "storage corruption"],
        "GREEDY_CONTRACT": ["greedy", "funds locked", "unwithdrawable"],        
        "UNINITIALIZED_STORAGE": ["uninitialized state variable", "not initialized", "default value in state", "SOLIDITY_VISIBILITY"],
        "DOS_GAS_LIMIT": ["out-of-gas", "dos", "gas limit"],
        "VERSION_PRAGMA": ["SOLIDITY_PRAGMAS_VERSION"],
        "OUTDATED_SOLC": ["SOLIDITY_UPGRADE_TO_050"],
        
    }

    def __normalize_text(self, *texts):
        return " ".join(filter(None, texts)).lower()


    def classify_finding(self, tool_id, finding):
        """Return classification metadata for a finding."""          
        info = sb.tools.info_finding(tool_id, finding.get("name"))
        classification = info.get("classification", "")
        
        text_blob = self.__normalize_text(
            classification,
            finding.get("name", ""),
            finding.get("message", "")
        )

        categories = set()
        matched_keyword = None

        for swc, category in self.SWC_MAP.items():
            if swc.lower() in classification.lower():
                categories.add(category)

        for category, keywords in self.KEYWORDS.items():
            if any(kw in text_blob for kw in keywords):
                categories.add(category)
                matched_keyword = category

        result = {
            "name": finding.get("name", "unknown"),
            "filename": finding.get("filename", "unknown"),
            "line": finding.get("line", -1),
            "severity": finding.get("severity", "unknown"),
            "categories": list(categories) if categories else ["UNCLASSIFIED"],
            "matched_keyword": matched_keyword
        }
        
        return result

    def analyze(self, tool_id, parsed_output):
        """Return list of detailed categorized findings."""
        findings = parsed_output.get("findings", []) if parsed_output else []
        results = []

        for finding in findings:
            result = self.classify_finding(tool_id, finding)
            #if "UNCLASSIFIED" in result["categories"]:
                #sb.logging.message(f"Unclassified finding: {result}", "DEBUG")
            results.append(result)

        #sb.logging.message(f"Detected vulnerabilities: {detailed_results}", "DEBUG")
        return results