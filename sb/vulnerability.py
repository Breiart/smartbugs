import re
import sb.logging
import sb.tools

class VulnerabilityAnalyzer:
    """Analyze findings and classify vulnerabilities."""

    SWC_MAP = {
        "SWC-100": "DEFAULT_VISIBILITY",
        "SWC-101": "INTEGER_OVERFLOW",
        "SWC-102": "OUTDATED_COMPILER",
        "SWC-103": "VERSION_PRAGMA",
        "SWC-104": "LOW_LEVEL_CALL",
        "SWC-105": "UNLOCKED_ETHER",
        "SWC-106": "SUICIDAL",
        "SWC-107": "REENTRANCY",
        "SWC-109": "UNINITIALIZED_STORAGE_POINTER",
        "SWC-110": "ASSERT_VIOLATION",
        "SWC-111": "DEPRECATED_FUNCTION",
        "SWC-112": "DELEGATECALL",
        "SWC-113": "DOS_GAS_LIMIT",
        "SWC-114": "TOD",
        "SWC-115": "BLOCK_DEPENDENCE",
        "SWC-116": "BLOCK_DEPENDENCE",
        "SWC-117": "SIGNATURE_MALLEABILITY",
        "SWC-119": "VARIABLE_SHADOWING",
        "SWC-120": "WEAK_RANDOMNESS",
        "SWC-123": "WRITE_TO_ARBITRARY_STORAGE",
        "SWC-124": "WRITE_TO_ARBITRARY_STORAGE",
        "SWC-127": "ARBITRARY_JUMP",
        "SWC-130": "ENCODING_BUG",
        "SWC-131": "UNUSED_STATE_VARIABLE",
        "SWC-132": "STRICT_BALANCE_EQUALITY",
        "SWC-133": "ENCODING_BUG",
        "SWC-135": "GREEDY_CONTRACT",
        "SWC-136": "UNINITIALIZED_STORAGE",
        "SWC-138": "DOS_GAS_LIMIT",
    }

     # Mapping for DASP10 classification tags
    DASP_MAP = {
        "DASP-1": "REENTRANCY",
        "DASP-2": "ARBITRARY_SEND",
        "DASP-3": "OVERFLOW",
        "DASP-4": "LOW_LEVEL_CALL",
        "DASP-5": "DOS_GAS_LIMIT",
        "DASP-6": "WEAK_RANDOMNESS",
        "DASP-7": "FRONT_RUNNING",
        "DASP-8": "BLOCK_DEPENDENCE",
    }

    KEYWORDS = {
        "INTEGER_OVERFLOW": [
            "overflow", "underflow", "arithmetic error", "unchecked math",
            "integer_arithmetic_bugs_swc_101", "overflow_bugs", "underflow_bugs",
            "integer_overflow", "divide_before_multiply", "solidity_div_mul",
            "solidity_uint_cant_be_negative", "truncation_bugs"
        ],
        
        "OVERFLOW": ["overflow", "type overflow"],
        
        "UNDERFLOW": ["underflow", "integer_underflow"],
        
        "LOW_LEVEL_CALL": [
            "call.value", "low level call", "unchecked call",
            "external call without check", "solidity_call_without_data",
            "unchecked_low_level_call", "unchecked_return_value_from_external_call_swc_104",
            "avoid_low_level_calls", "low_level_calls", "avoid_call_value", "uncheckedtaintedstaticcall"
        ],
        
        "SUICIDAL": ["suicidal", "selfdestruct", "self-destruct", "destructible"],
        
        "REENTRANCY": [
            "reentrancy", "re-entrancy", "reentry", "re_entrancy_vulnerability",
            "reentrancy_bug", "reentrancy_eth", "reentrancy_unlimited_gas",
            "external_call_to_user_supplied_address_swc_107",
            "state_access_after_external_call_swc_107", "dao", "reentrancy_no_eth"
        ],

        "UNINITIALIZED_STORAGE_POINTER": ["uninitialized storage", "default value", "null storage"],
        
        "UNINITIALIZED_STORAGE": [
            "uninitialized state variable", "not initialized", "default value in state",
            "uninitialised_struct", "init_variables_with_default_value",
            "uninitialized_storage", "uninitialised struct"
        ],
        
        "ASSERT_VIOLATION": [
            "assertion failed", "assert failed", "assert violation", "assertion_failure",
            "exception_state_swc_110", "exception_disorder", "solidity_revert_require",
            "unhandled_exception", "unhandledexception", "avoid_throw"
        ],

        "DEFAULT_VISIBILITY": ["missing visibility", "default visibility", "solidity_visibility", "state_visibility", "func_visibility", "visibility_modifier_order", "solidity_private_modifier_dont_hide_data"],
        
        "DEPRECATED_FUNCTION": [
            "deprecated", "deprecated function", "deprecated_standards",
            "solidity_deprecated_constructions"
        ],
        
        "UNLOCKED_ETHER": [
            "ether leak", "arbitrary send", "leaking_ether",
            "unprotected_ether_withdrawal_swc_105", "gasless_send",
            "no_ether_leak_no_send", "no_ether_lock_ether_refused",
            "unrestrictedetherflow", "ether_leak_verified", "money_flow",
            "non_payable_constructor"
        ],
        
        "DELEGATECALL": ["delegatecall", "delegate call"],
        
        "TX_ORIGIN": ["tx.origin", "tx origin", "origin authentication", "dependence_on_tx_origin_swc_115", "avoid_tx_origin", "solidity_tx_origin"],
        
        "TOD": [
            "transaction order dependence", "tod", "transaction_order_dependency",
            "transaction_ordering_dependence", "transaction_order_dependence_swc_114",
            "transaction_ordering_dependence_tod", "todamount", "todreceiver", "todtransfer"
        ],
        
        "BLOCK_DEPENDENCE": [
            "block.timestamp", "block.number", "now", "blockhash",
            "block_dependency", "block_number_dependency", "timestamp_dependency",
            "time_dependency_bug", "time_manipulation", "timestamp", "not_rely_on_time",
            "not_rely_on_block_hash", "dependence_on_predictable_environment_variable_swc_116",
            "dependence_on_predictable_environment_variable_swc_120",
            "solidity_exact_time"
        ],
        
        "WRITE_TO_ARBITRARY_STORAGE": ["arbitrary storage write", "storage corruption"],
        
        "GREEDY_CONTRACT": [
            "greedy", "funds locked", "unwithdrawable", "locked money",
            "locked ether", "daoconstantgas", "solidity_locked_money",
            "locking ether", "freezing ether"
        ],
        
        "MISSING_INPUT_VALIDATION": [
            "missing input validation", "missinginputvalidation",
            "solidity_overpowered_role", "missing_zero_check"
        ],
        "VARIABLE_SHADOWING": ["shadowing", "shadow variable", "shadowing_local"],
        
        "WEAK_RANDOMNESS": [
            "weak randomness", "predictable random", "weak prng",
            "bad randomness", "weak_prng"
        ],
                
        "ARBITRARY_JUMP": ["arbitrary jump", "jump to arbitrary"],
        
        "UNUSED_STATE_VARIABLE": ["unused state variable", "dead state"],
        
        "STRICT_BALANCE_EQUALITY": ["balance equality", "strict balance", "solidity_balance_equality"],
        
        "DOS_GAS_LIMIT": [
            "out-of-gas", "dos", "gas limit",
            "multiple_calls_in_a_single_transaction_swc_113",
            "callstack_depth_attack_vulnerability", "callstack_bug", "concurrency_bug",
            "solidity_extra_gas_in_loops", "solidity_gas_limit_in_loops",
            "array_length_outside_loop", "controlled_array_length", "cache_array_length",
            "costly_loop", "state_variable_read_in_a_loop",
            "unnecessary_checked_arithmetic_in_loop", "inefficient_state_variable_increment",
            "max_states_count", "unboundedmassop"
        ],                
        
        "VERSION_PRAGMA": ["solidity_pragmas_version", "solc_version", "compiler_version"],
        
        "OUTDATED_SOLC": ["solidity_upgrade_to_050"],
        
        "ARBITRARY_SEND": ["arbitrary_send_eth", "solidity_erc20_approve", "solidity_send", "payable_fallback"],
        
        "SIGNATURE_MALLEABILITY": ["signature malleability", "ecdsa malleable"],
        
        "ENCODING_BUG": ["bidi", "unicode", "encoding", "collision"],        
    }

    def __normalize_text(self, *texts):
        return " ".join(filter(None, texts)).lower()


    def classify_finding(self, tool_id, finding):
        """Return classification metadata for a finding."""          
        info = sb.tools.info_finding(tool_id, finding.get("name"))
        classification = info.get("classification", "")
        
        text_blob = self.__normalize_text(
            classification,
            finding.get("name", ""),
            finding.get("message", "")
        )

        categories = set()
        matched_keyword = None

        for swc, category in self.SWC_MAP.items():
            if swc.lower() in classification.lower():
                categories.add(category)
        
        for dasp, category in self.DASP_MAP.items():
            if dasp.lower() in classification.lower():
                categories.add(category)

        for category, keywords in self.KEYWORDS.items():
            if any(kw in text_blob for kw in keywords):
                categories.add(category)
                matched_keyword = category

        result = {
            "name": finding.get("name", "unknown"),
            "filename": finding.get("filename", "unknown"),
            "line": finding.get("line", -1),
            "severity": finding.get("severity", "unknown"),
            "categories": list(categories) if categories else ["UNCLASSIFIED"],
            "matched_keyword": matched_keyword
        }
        
        return result

    def analyze(self, tool_id, parsed_output):
        """Return list of detailed categorized findings."""
        findings = parsed_output.get("findings", []) if parsed_output else []
        results = []

        for finding in findings:
            result = self.classify_finding(tool_id, finding)
            #if "UNCLASSIFIED" in result["categories"]:
                #sb.logging.message(f"Unclassified finding: {result}", "DEBUG")
            results.append(result)

        #sb.logging.message(f"Detected vulnerabilities: {detailed_results}", "DEBUG")
        return results
