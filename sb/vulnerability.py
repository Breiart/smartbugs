import re
import sb.logging
import sb.tools

class VulnerabilityAnalyzer:
    """Analyze findings and classify vulnerabilities."""

    SWC_MAP = {
        "SWC-100": "DEFAULT_VISIBILITY",
        "SWC-101": "INTEGER_OVERFLOW",
        "SWC-102": "OUTDATED_COMPILER",
        "SWC-103": "VERSION_PRAGMA",
        "SWC-104": "LOW_LEVEL_CALL",
        "SWC-105": "UNLOCKED_ETHER",
        "SWC-106": "SUICIDAL",
        "SWC-107": "REENTRANCY",
        "SWC-109": "UNINITIALIZED_STORAGE_POINTER",
        "SWC-110": "ASSERT_VIOLATION",
        "SWC-111": "DEPRECATED_FUNCTION",
        "SWC-112": "DELEGATECALL",
        "SWC-113": "DOS_GAS_LIMIT",
        "SWC-114": "TOD",
        "SWC-115": "BLOCK_DEPENDENCE",
        "SWC-116": "BLOCK_DEPENDENCE",
        "SWC-117": "SIGNATURE_MALLEABILITY",
        "SWC-119": "VARIABLE_SHADOWING",
        "SWC-120": "WEAK_RANDOMNESS",
        "SWC-123": "WRITE_TO_ARBITRARY_STORAGE",
        "SWC-124": "WRITE_TO_ARBITRARY_STORAGE",
        "SWC-127": "ARBITRARY_JUMP",
        "SWC-130": "ENCODING_BUG",
        "SWC-131": "UNUSED_STATE_VARIABLE",
        "SWC-132": "STRICT_BALANCE_EQUALITY",
        "SWC-133": "ENCODING_BUG",
        "SWC-135": "GREEDY_CONTRACT",
        "SWC-136": "UNINITIALIZED_STORAGE",
        "SWC-138": "DOS_GAS_LIMIT",
    }

    KEYWORDS = {
        "INTEGER_OVERFLOW": ["overflow", "underflow", "arithmetic error", "unchecked math"],
        "LOW_LEVEL_CALL": ["call.value", "low level call", "unchecked call", "external call without check", "SOLIDITY_CALL_WITHOUT_DATA"],
        "SUICIDAL": ["suicidal", "selfdestruct", "self-destruct", "destructible"],
        "REENTRANCY": ["reentrancy", "re-entrancy", "reentry"],
        "UNINITIALIZED_STORAGE_POINTER": ["uninitialized storage", "default value", "null storage"],
        "ASSERT_VIOLATION": ["assertion failed", "assert failed", "assert violation"],
        
        "DEFAULT_VISIBILITY": ["missing visibility", "default visibility"],
        "DEPRECATED_FUNCTION": ["deprecated", "deprecated function"],
        "UNLOCKED_ETHER": ["ether leak", "arbitrary send"],

        "DELEGATECALL": ["delegatecall", "delegate call"],
        "TX_ORIGIN": ["tx.origin", "tx origin", "origin authentication"],
        "TOD": ["transaction order dependence", "tod"],
        "BLOCK_DEPENDENCE": ["block.timestamp", "block.number", "now", "blockhash"],
        "WRITE_TO_ARBITRARY_STORAGE": ["arbitrary storage write", "storage corruption"],
        "GREEDY_CONTRACT": ["greedy", "funds locked", "unwithdrawable", "locked money", "locked ether"],
        "MISSING_INPUT_VALIDATION": ["missing input validation"],
        "UNINITIALIZED_STORAGE": ["uninitialized state variable", "not initialized", "default value in state", "SOLIDITY_VISIBILITY"],
        "VARIABLE_SHADOWING": ["shadowing", "shadow variable"],
        "WEAK_RANDOMNESS": ["weak randomness", "predictable random", "weak prng", "bad randomness"],
        "ARBITRARY_JUMP": ["arbitrary jump", "jump to arbitrary"],
        "UNUSED_STATE_VARIABLE": ["unused state variable", "dead state"],
        "STRICT_BALANCE_EQUALITY": ["balance equality", "strict balance"],
        "DOS_GAS_LIMIT": ["out-of-gas", "dos", "gas limit"],
        "VERSION_PRAGMA": ["SOLIDITY_PRAGMAS_VERSION"],
        "OUTDATED_SOLC": ["SOLIDITY_UPGRADE_TO_050"],

        "SIGNATURE_MALLEABILITY": ["signature malleability", "ecdsa malleable"],
        "ENCODING_BUG": ["bidi", "unicode", "encoding", "collision"],
        
    }

    def __normalize_text(self, *texts):
        return " ".join(filter(None, texts)).lower()


    def classify_finding(self, tool_id, finding):
        """Return classification metadata for a finding."""          
        info = sb.tools.info_finding(tool_id, finding.get("name"))
        classification = info.get("classification", "")
        
        text_blob = self.__normalize_text(
            classification,
            finding.get("name", ""),
            finding.get("message", "")
        )

        categories = set()
        matched_keyword = None

        for swc, category in self.SWC_MAP.items():
            if swc.lower() in classification.lower():
                categories.add(category)

        for category, keywords in self.KEYWORDS.items():
            if any(kw in text_blob for kw in keywords):
                categories.add(category)
                matched_keyword = category

        result = {
            "name": finding.get("name", "unknown"),
            "filename": finding.get("filename", "unknown"),
            "line": finding.get("line", -1),
            "severity": finding.get("severity", "unknown"),
            "categories": list(categories) if categories else ["UNCLASSIFIED"],
            "matched_keyword": matched_keyword
        }
        
        return result

    def analyze(self, tool_id, parsed_output):
        """Return list of detailed categorized findings."""
        findings = parsed_output.get("findings", []) if parsed_output else []
        results = []

        for finding in findings:
            result = self.classify_finding(tool_id, finding)
            #if "UNCLASSIFIED" in result["categories"]:
                #sb.logging.message(f"Unclassified finding: {result}", "DEBUG")
            results.append(result)

        #sb.logging.message(f"Detected vulnerabilities: {detailed_results}", "DEBUG")
        return results